Compiler Gyaan
gcc code.c -o [name that you want to give] // to give the compiled file a name other than a.exe

gcc -Wall -save-temps zero.c // To see all the files which gets generated during the compilation of the code with .i for preprocessed code, .s for assembly code and .o for (final) binary file which the computer understands 
// Note: The -[command] are known as flags of gcc

preprocessing = the compiler removes all the comments from the code and includes all code from the libraries which we have mentioned
compilation = then the preprocessed code is run with fix memory allocated
assembly = then the code gets converted into assembly lang
linking = all files are linked together to generate an executable(.exe) file

PREPROCESSORS IN C
#include "code.c" // this is how to include other file's code into another code, like npm in JS
#define PI 3.14 // this is called a macro, aka, the define directive
#define SQUARE(r) r*r // this means whenever there will be SQUARE(r) written, it'll be replaced by r*r
#undef // it makes macro undefined
#pragma // to issue some advanced/special commands to the compiler
#ifdef // if a macro is defined, it returns true(1)
#ifndef // if a macro isn't defined, it returns true

PREPROCESSOR DIRECTIVES
printf("The file name is %s\n", __FILE__);               // To print the file name
    printf("Today's date is %s\n", __DATE__);                // To print the date
    printf("The time is %s\n", __TIME__);                    // To print the time
    printf("Compiled with ANSI Standards?: %d\n", __STDC__); // To check if your code is compiled using ANSI Standards, 1 if yes, 0 if no

#ifdef DATE // if date is defined, than only go in this, otherwise don't
    printf("%s", __DATE__);
#endif

#ifndef TIME // if time is NOT defined, than only go in this, otherwise don't
    printf("%s", __TIME__);
#endif

----------------------------------
int a; // this means initializing a variable
int a = 5; // this means declaring a variable
----------------------------------
VARIABLES IN C
----------------------------------
fOrMaT sPeCiFiErS
%c - character
%f - float
%d - integer
%l - long
%u - 
%lf - double
%LF - long double

dEfInInG cOnStAnTs
const [var type] [var name] = [var value];
#define PI 3.14 // no need to insert semicolon here
----------------------------------
STORAGE CLASSES IN C
1. Automatic Variables // the most common, the variable decides itself if it is local or global
2. External Variables // the global variables, which should be avoided, as any function can change it and will not free-up the memory allocated to it until the whole program is over
3. Static Variables // the variables which are constant, which holds the previous value they had been assigned
4. Register Variables // the cpu decides if a register is available to store and process data in the processor memory. It is generally used to store the variables which are frequently used in the program


To use the variable outside your function, and from global scope, you need to insert 'extern' before declaring the variable, but not defining it.
i.e. int func(){ extern int sum; }
	int sum = 343; // in order to use this variable, we must use extern inside the func()
----------------------------------
PRINTING RANDOM INTEGERS BETWEEN 1 AND 1OO
srand(time(NULL));
    int random = rand() % 100; // replace '100' with the number till which's range you want the random number from
    printf("%d", random);
----------------------------------

Strings in C

---------------
char name[] = "jeel"; // compiler automatically adds a null character when string is stored as here
char name[] = {'j','e','e','l','\0'}; // this is how to store individual characters

---------------
ASSIGNING STRINGS TO ARRAY
char str1[1];
scanf("%s", str1); // if you enter a word having more than 1 character, it works perfectly fine!
printf("%s\n", str1);

BUT
char str2[2] = "hello";
printf("%s\n", str2); // this will print only 'he' as we have declared that the array only contains 2 characters, hence the other characters are terminated
---------------

scanf - This will not store the word entered after a space, i.e. - If you entered James Bond in scanf prompt, it'll only accept and store James from it.

scanf("%s", stringGoesInHere); // To store a string, no need to have an ampersand(&) before the variable

// Ideal way to use strings
char oneString[4];
fgets(oneString, 4, stdin);
puts(oneString);

----------

SWITCH STATEMENT
The variable being switched in the switch statement must be a char or an int.
There is no need to include break; in the default statement
----------

CONTINUE IN C
int i = 0;
    while (i < 10)
    {
        i++;
        if (i == 5) // if the i is 5, the below 				code in the block				(in this case, 				printf, won't be 				executed
        {
            continue;
        }
        printf("%d", i);
    }
----------

GOTO   I N   C
- avoid using it. It is avoided since it causes confusion among fellow programmers in understanding the code
- It is used when we need to break multiple loops using a single statement at the same time.
label:

goto label; // this will make the code process jump to where the label is, and process it again

break; // this exits it's own block, but if we want to exit every function block, we can use goto.
----------

TYPECASTING SYNTAX
(varType) var
i.e. - (int) myVar

NOTE: the arithmetic operations done between int and float will have result as int, to get float, we need to typecast while performing the arithmetic op
----------
sqrt(2); // * requires math.h * for square rooting 2
pow(2, 4);

----------
FUNCTIONS IN C

There are four types of functions in C
1. Without arguments and without return value
2. Without arguments and with return value
3. With arguments and without return value
4. With argumments and with return value

1. void printTableOfTwo()
{
    int i = 0;
    while (i < 10)
    {
        printf("%d X %d = %d\n", 2, i + 1, (i + 1) * 2);
        i++;
    }
}
2. void getNumber(){
		int i;
		scanf("%d",&i);
		return i;
	}
3. void printStar(int numberOfStars){
	int i=0;
	while(i<numberOfStars){
		printf("%c", '*');
		i++;
	}
4. int sum(int a, int b){return a + b;}
----------

FOR LOOPS
You can use for loops as

int i=0,j=0;
for(i<5, j<10, j++){
	printf("%d %d\n", i,j); // this will iterate 10 times
}

// This one's fascinating, as the compiler will follow the max(bigger, in this case j<10) condition if it's true or false and will keep incrementing i, so here the j will always be true because it's not incrementing and hence this'll run infinite times!
int i = 0, j = 0;
    for (i < 5; j < 10; i++)
    {
        printf("%d %d\n", i, j);
    }
----------

A TWO DIMENSIONAL ARRAY
    char great[3 /*The number of elements in the array */][10 /*The number of characters in an element + the null character*/] = {
        "Behold",
        "Skywalker",
        "Luke"};

  0 1 2 3 4 5
0 B E H O L D
1 L U K E
2 S K Y W A L K E R

----------
----------

STRUCTURES (as OBJECTS in JS) in C
struct bank
    {
        int acc;
        float balance;
        char username[64];
    };
    struct bank current, savings /* This can be changed to anything, plus you can add more variables too! and then define it like # */;
    
    current.balance = 23400.45;
    current.acc = 185060311;
    savings.balance = 46900.78; # like this!
    savings.acc = 185034211;

    printf("your account number is %d, and your current balance is %f", current.acc, savings.balance); // here, the . dot operator is also known as stucture member operator

----------
    strcpy(tpom.name, "The Psychology of Money"); // this is how you can add a string to a struct variable
----------
struct books trbe, tpom; // if we declare this variables inside main(), it won't be used outside main()
----------

STRUCT TYPEDEF
	typedef int i; // in the case of simple variable
    	i myVar = 10; 	// It is used to give an alias to a variable datatype
TYPEDEF IN STRUCT
	typedef struct student{
		char name[50];
		int enrollment;
	} std;
we can use it as following in main():
	std s1,s2;
	s1.id = 10;
----------

TO DEFINE TYPEDEF VARIABLE WHICH WILL MAKE EVERY VARIABLE A POINTER
int *a,b; // this will make the 'a' varible a pointer, and 'b' a normal int variable, but if we want to make every variable declared to be a pointer, 			then,
typedef int* intPtr;
intPtr a,b; // this will make every variable a pointer without inserting an asterisk

----------
UNIONS IN C

It is user defined datatype, it is very similar to a structure.
Structure: It allocates different memories to its members
Unions: It allocates a single shared memory 
----------

OBJECTS USING STRINGS!
struct senate
    {
        char name[64];
        int age;
    };

    struct senate primeMinister = {
        "Justin Trudeau",
        34};

// THIS CAN BE ALSO WRITTEN AS THIS!
// struct senate
//  {
//      char name[64];
//      int age;
//  }; primeMinister = {
//      "Justin Trudeau",
//      34};

    printf("The prime minister of Canada is %s, who is %d years old!", primeMinister.name, primeMinister.age);

----------
----------

POINTERS
Pointer variables are used to store an address of a variable,
i.e. - Suppose my variable is jediMaster, and I want to know its address at which is located in my pc, I'll print with the %p placeholder and write &jediMaster after the comma! But if I want to store it into an another variable I'll do the below!

    int var;
    int *pointer;

    pointer = &var; // This store the address of var in 'pointer' variable
    value = *pointer // But this will store the 'pointer' variable's value to the 'value' variable

    printf("%p\n", &var);
    printf("%p", pointer);
---------------------------------
VOID POINTER
Void Pointers is like a general container, which you can use for any purpose
- It can be typecasted into any variable datatype
- You can't dereference it through our traditional pointer dereferencing way! You need to first typecast the void pointer into the datatype of which the data is on the address location, so, if you don't know the datatype of variable stored, you won't be able to dereference it/get the value stored in it
i.e.
    int y = 7;
    float z = 1.3;
    void *ptr;
    ptr = &y;
    printf("%d", *((int *)ptr));
    ptr = &z; // we can use void pointer like this, to store and display two kinds of data, that's why it is known as 'general purpose' pointer
    printf("%f", *((float *)ptr));
---------------------------------
ANOTHER ONE
int a = 76;
int *ptra = &a;

%p , &ptra // ptra ek esa variable hai jiske andar to ek variable ka address hai hi, but &ptra uska khudka address hai
%p , &a // ye a ka address hai
%p , ptra // a ka address to maine ptra mein store kiya tha, so instead of &a, we can also write ptra only
%d , *ptra // ye print krta hai vo value jo ki vo address me hai jo address ptra me stored hai(here, a ki value)
%d , a // ye bhi a ki value print krega, so instead of *ptra, we can write this!


int arr[] = {0,1,2};
%d, arr+1; // This will print the address of second element of the array, not value, not address of first element
%d, *(arr+1) // This will print the value of second element; This and below statement prints the same
%d, *(&arr[1]); // This is called value dereferencing
%d, arr[1]; // our traditional way to print value of an array element


here, [int arr[] = {0,1,2};] is a constant, and you cannot change its address or perform arithmetic ops on it like arr++/a--.
but, you can assign and change value of it like this: int *arrPtr = arr; - - This assigns the original addresses of arr to the *arrPtr and hence we can manipulate those addresses and its values, quite complex!

----------
----------

#include <stdio.h>

void display(); // function prototype

void main()
{
    display();  // function call
}

void display()
{
    puts("Hello!");  // function definition
}

----------
----------

Converting the type of a variable -- also known as typecasting

void main()
{
    float a = 3.4;
    printf("%d", (int)(a));
}

Rounding off in C / Deciding how many digits should be printed after decimal point

float a = 3.45667;
printf("%.2f", a); // 3.46 (It also rounds off the figure, How cool!)
ALSO
printf("Value of d is %14.5f\n", 4.34); // Value of d is        4.34000
	~> The 14 and 5 in %14.5f is the values to be printed before and after the decimal point, so if there are more values mentioned then the value itself, it'll leave spaces


----------
----------

To get the address of a variable = *a
To get the variable/constant stored inside an address = *(&a)

int *j; // This means that 'j' is going to be used to store integer addresses,
vice versa for other variable types

int i = 12, *j = &i; // *j stores the variable stored in i
printf("value of i = %d\n", i); // 12
printf("value of j = %d", *j); // 12

----------
----------

As j is used to store the address of i, we can use k to store the address of j, like this:
int **k;
r = &j;
we can go on and on by adding asterisks like above. as every address storing variable would obviously have their own address too!

----------
----------

Reference by Value
void swap(int *a, int *b);

void main()
{
    int a = 3, b = 4;
    printf("value of a and b before swap: %d %d\n", a, b);
    swap(&a, &b);
    printf("value of a and b after swap: %d %d\n", a, b);
}

void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

----------
----------

*avg = (float)*sum / 2; // this means that the result should be typecasted to float data type

----------
----------

POINTER TO POINTER

int a = 12;
    int *b = &a;
    int **c = &b;
    int ***d = &c;

    printf("%u\t %u\t %u\t %u\t", a, b, c, d);

----------
----------

POINTER ARITHMETIC

int a, *p = &a;
printf("original address of a: %u\n", p);
p++; // Increases the address by 4 bytes(only in integer and float), whereas it'll only plusplus by 1(1 byte) if 'p' would be char datatype | This'll only change the address that is copied in 'p' and not the original address of a
printf("plusplused address of a: %u, original address of a: %u\n", p, &a);

----------
FIBONACCI SERIES USING ITERATIVE AND RECURSIVE METHOD
----------
#include <stdio.h>

int fibR(int num)
{
    if (num == 1 || num == 2)
    {
        return (num - 1);
    }
    else
    {
        return fibR(num - 1) + fibR(num - 2);
    }
}

int fibI(int num)
{
    int a = 0, b = 1;
    for (int i = 0; i < num - 1; i++)
    {
        b = a + b;
        a = b - a;
    }
    return a;
}

int main()
{
    int num;
    printf("Enter number till which you want fibonacci numbers: ");
    scanf("%d", &num);
    printf("Iterative Method: %d\nRecursive Method: %d", fibI(num), fibR(num));
    return 0;
}

----------
V E R Y IMPORTANT ! ! !
----------

FUNCTIONS IN C
in functions, the parameters passed from the main() function are called 'actual parameters' and when there is a copy made of those actual parameters in the function, they're known as formal parameters

CALL BY VALUE/REFERENCE
1. When a value is passed as actual and formal parameters, it is called Call By Value
2. When ann address is passed to a function as a parameter, it is known as Call By Reference
	i.e. - in main() - funct(&variable); // I'm sending this variable's address to the function as a parameter
		in whateverFunction(int *variable){ } // I'm receiving the address of the passed variable

Note: Functions wouldn't be able to change the value of a parameter through call by value, but it can change through call by reference, cause it has the address of it!

BEST EXAMPLE: When a smart contract is written on the blockchain, it gets distributed on each and every server working, and if you change one of those smart contract, you won't be able to change them all, but if you change the smart contract as a sudo user/root user/administrator, It will be a disaster!!!

SIMPLE CALL BY REFERENCE EXAMPLE (only variable, not array)
i.e. int func(int *ptr){
	*(ptr) will give me the value of the very first element in the array!   
	*(ptr+1); // this is called dereferencing, through which we'll get the second element of the array(ptr+1 = 2nd element)
likewise,  *(ptr+2) will give me the value of the third element

void changeValue(int *address){
	*address = 47;
}

int main(){
	int a = 34;
	changeValue(&a); // now it's value would be 47
}

 --- By declaring array as a parameter in the function ---

in main():
	int product = func(arr); // this is how array is passed to a function

in function():
	int func(int arr[]){for(int i; i<4; i++) 
	{
	"%d", arr[i]; // to iterate all elements
	}
} // If you change the value of any array element, it'll be reflected in original value


SIMPLE CALL BY REFERENCE EXAMPLE (array) --- By passing array's base address to the function ---

Just name of the array (for i.e. arr[10]) has the address of its first element in the name of it(here, arr)
i.e.
in function():
	void func(int *ptr){
	{for(int i; i<4; i++) 
	{
	"%d", arr[i]; // to iterate all elements // you can also write *(ptr+i) instead of arr[i]
	}
}

in main():
	avg = func(arr); // this only passes the address of the first element, then we can change values of all elements by incrementing the address by 1!!! HOW FUCKING AWESOME IS THAT!


----------
----------
T W O DIMENSIONAL A R R A Y S
inside main():
	int arr[][2] = {{1,2}, {3,4}};
	func(arr);

inside void func(int arr[2][2]):
	{
		for(int i=0; i<2; i++){
			for(int j=0; j<2; j++){
				printf("The value at %d, %d is %d", i, j, arr[i][j]);
			}	
		}
	}

----------
----------

\0 - null character
- a separate character string is stored as char str[] = {'j','e','e','l','\0'}
- a whole string is stored as char str[] = "jeel";

----------
Printing Address of each character in a string
----------

char arr[] = {"jeel"};
    // scanf("%s", arr);
    for (int i = 0; i < sizeof(arr); i++)
    {
        printf("Address of %c is %u\n", arr[i], &arr[i]);
}

Out: 
Address of j is 1520434199
Address of e is 1520434200
Address of e is 1520434201
Address of l is 1520434202
Address of   is 1520434203 (this is null(\0) character)

----------
Scanf will not work if entered string have spaces in it
----------
In order to allow user enter a sentence with spaces, we use gets() and puts()
scanf("%s", s) is equivalent to gets(s)
printf("%s", s) is equivalent to puts(s)

----------
*ptr = "JEEL" is equivalent to ptr[] = "JEEL";
----------
ptr[] initilization method won't allow you to change the content on the existing address
BUT
*ptr will allow you to do this!

----------
Mysterious 'sizeof(str)'
----------
when used to analyze the size of an array, like
	char str[] = "Jeel";
	printf("%d", sizeof(str));
It'll output 5(including \0)
BUT
when used to analyze the size of a pointer variable, like
	char *str = "Jeel";
	printf("%d", sizeof(str));
It'll output 8(as it is meant to be storing an address of 8 bit!)


----------
Game of string.h
----------
strcpy(target, source);
strcat(oneString, nextString);
strcmp

----------
FFLUSH(STDIN);
The fflush(stdin); clears the previous input
void zoop() // in order to flush the previous input (healthier alternative of fflush(stdin))
{
    int c;
    while ((c = getchar()) != '\n' && c != EOF)
    {
    }
}
----------

IF WANT TO CHANGE INDIVIDUAL ELEMENTS OF AN ARRAY, USE ARRAY[] METHOD, OTHERWISE *ARRAY WOULD WORK!

YOU CAN USE gets() to enter strings with spaces!


----------
THE indeSTRUCTible IN C (as Object in JS)
----------

struct employee
{
    int code;
    float salary;
    char name[50];
};
void main()
{
    struct employee e1; // can have e1[100] = array of structures
    printf("Enter the name of employee");
    scanf("%s", e1.name); // strcpy(e1.name,"Jeel") if want to manually store a string
}
------------
CREATING AN ALIAS OF STRUCT
------------
This creates an alias of the struct! So, now you don't need to write 'struct employee' in 'struct employee e1'
typedef struct employee
{
    int code;
    float salary;
    char name[50];
} emp;

------------
ALTERNATE WAY TO INITIALIZE STRUCT
------------
a struct can be initialized as this too:
	struct employee e1 = {100, 100, "Jeel"}; // data inserted should be in proper sequence
------------
RESET A STRUCT
------------
to reset a struct
	struct employee e1 = {0};

----------
MAKING POINTER VARIABLES IN STRUCT
----------

struct employee e1;
struct employee *ptr;

ptr = &e1;
(*ptr).code = 101; // you can also write ptr->code = 101;

------------
FILES I/O
------------
FILE *ptr;
ptr = fopen("tes.c", "a"); // this appends data to existing data

2 Types of files - Text files(.txt,.c) & Binary files(.jpg,.bat)

------------
READ AND FETCH DATA FROM DIFFERENT FILE
------------

fscanf(ptr, "%d", &num); // it works similar to normal scanf, but this one deals with files, its format is fscanf([source_variable], [data_type_to_capture], [target_variable])

I.E
FILE *ptr;
ptr = fopen("tes.c", "r");
int num;
int num2;
fscanf(ptr, "%d", &num);
fscanf(ptr, "%d", &num2); // the value after space will be stored in num2
printf("%d", num);

fclose(ptr); // close a file after you've used it and not going to use it again

------------
WRITE A FILE
------------
FILE *ptr;
ptr = fopen("generated.c", "w"); //File will be created if doesn't exist
char string[50] = "Hello C";
fprintf(ptr, "Hello World!"); // If changed the content, the previous content would be replaced completely
fprintf(ptr, "%s", string); // print data to 'ptr', the datatype is '%s', and the data which will be printed is in 'string' variable
fclose(ptr); // to free up the program memory

------------
READ FILE
------------
FILE *ptr = NULL; // It is a healthy practice to NULL a pointer to avoid future errors
char string[50];
ptr = fopen("generated.txt", "r");

// to fetch a word
fscanf(ptr, "%s", string); // ptr = the file from which we're fetching, %s = the datatype of which the data is, "string" = the variable in which the fetched data will be stored in
printf("%s",string);

// to fetch a word/sentence character by character
for (int i = 0; i < 10; i++)
    {
        printf("%c\n", fgetc(ptr));
    }
fclose(ptr); // to free up the program memory

------------
PUTS() IN FILE I/O // Prints data in other files
------------
FILE *ptr;
ptr = fopen("generated.txt", "w");
putc('j', ptr); // you can only print one character in other file with this, or you can replace putc with puts and write a whole string
fclose(ptr); // to free up the program memory

------------
------------
FILE *fptr;
    fptr = fopen("generated.txt", "r");
    char c = fgetc(fptr); // This fetches and prints every character from the other file, or you can use fgets to fetch a whole string
    while (c != EOF) // EOF = End of File
    {
        printf("%c", c);
        c = fgetc(fptr);
    }
	fclose(ptr); // to free up the program memory

------------
------------
ADVANCED FILE I/O METHODS

r - 	Opens an existing text file for reading.

w - 	Opens a file for writing.
	Creates a file if it does not exist.
	Writing starts from the beginning of the file.

a - 	Opens a text file for writing in appending mode.
	Creates a file if it does not exist.
	The program will start appending content to the existing file content.

r+ - 	This mode will open a text file for both reading and writing

wt - 	Opens a text file for both reading and writing. 
	Creates a file if it does not exist.
	It replaces every content when written.

a+ - 	Opens a text file for both reading and writing. 
	Creates a file if it does not exist.
	It can only append to file.

------------
dynamiC (Memory Allocation - malloc)(contiguos allocation - calloc)
------------
int *ptr;
ptr = malloc(6*4); // I want 6 integers with 4 byte capacity, but to improve the accessibility of the program, we would use 'sizeof(int)' instead of 4 so that lower and higher end PCs with more bytes can also work seamlessly

------------
ptr = (int*) malloc(30*sizeof(int)); // (int*) here is typecasting, as the malloc function returns void, we've to convert it into integer(or the datatype that you want) -- we can use ptr afterwards as an array, and it will continue allocating memory dynamically
------------

ptr = (float*) calloc(6, sizeof(float)); // allocates contiguos space in memory. It allocates on the spot, and not dynamically, hence when printed a variable without storing any data, it will show 0

// Difference between malloc and calloc is that malloc initializes our memory with garbage values and calloc initializes with 0

------------
POINTER TYPES

Void Pointer is a general purpose pointer(which is like a general purpose container, which can be use to store anything from detergent to food, etc. and not limited to only one purpose). It can be transformed to any variable datatype

Null Pointer is a way to make a pointer variable be NULL(0) so that no-one can dereference it. It will make the pointer variable point no longer to a garbage value, hence you'll have one less possibility of an error
i.e. Null pointer can be checked if it is null and then use it, but if null pointer isn't made null beforehand, it can cause troubles inside your program
another i.e. - You will want to store in a pointer only if it isn't NULL(because you've made it null), so that you don't continue your program taking a garbage value instead(illustration below)
-> 
int a = 3;
int *ptr = &a;
if(ptr != NULL)  // checks if the pointer is null or not to avoid troubles caused later in the code
	printf("The address of a is %d", *ptr);
else{
	printf("The pointer is a null pointer and can't be dereferenced");
}

Dangling Pointer - The pointer which is pointing to the variable which is deleted or deallocated now 
Wild Pointer - Uninitialized pointer variable is called wild pointer,
i.e.
int a;
int *ptr;
ptr = &a; // ptr is not a wild pointer anymore

---------------------------------
---------------------------------

COMMAND LINE ARGUMENTS

***************************ARGC & ARGV*************************
int main(int argc, char const *argv[]); // here, argc is the first argument when giving input in the main() function, and argv is an array in which every command is stored, and it has atleast one command, which is the file name(i.e. zero.exe)

{
	printf("argc: %d", argc); // this will print 3 if the command in the terminal is something like this = = ./zero.exe jeel patel, the 1st being its file name, and the both strings as separate arguments
}

another example: 
// printing all the arguments that are stored in argv[] array

for(int i=0; i<argc; i++){
	printf("argument:%d, value: %s", i, argv[i]); // the code needs to be saved and executed before inputting "./zero.exe jeel patel" in the terminal
}

Note: argv[] always have the file address in its index[0]

Output:
argument: 0, value: C:\Users\JEEL\Desktop\C-Programs\FullCWHCourse\zero.exe
argument: 1, value: jeel
argument: 2, value: patel

IN ORDER TO UNDERGO ARITHMETIC INSTRUCTIONS, WE NEED TO CONVERT THE ARGUMENTS INTO INT(which are integers with double-quotes!)
printf("%d\n", (atoi(argv[1])) + (atoi(argv[2])));

------------------------------------------------
------------------------------------------------

THE POINTERS WHICH POINT TO A FUNCTION 'AKA' FUNCTION POINTERS

Note: Unlike normal pointers, we do not allocate/de-allocate memory using function pointers
i.e.
int sum(int a, int b)
{
    return a + b;
}
int main()
{
    int (*fPtr)(int, int); // point to a function which takes 2 integers as parameters and returns int as well
    fPtr = &sum;           // now, store the address where sum function is located, you can avoid '&' before 'sum'
    int d = (*fPtr)(4, 6); // the (*fPtr) would be replaced with sum and will fetch function outcome. This is also known as 'Dereferencing a function pointer'
    printf("%d", d);
    return 0;
}

---------------------------------------------------
---------------------------------------------------

CALLBACK FUNCTIONS
- Function Pointers are used to pass a function to a function
- This passed function can be called again, hence named 'Callback Function'

i.e.

int sum(int a, int b)
{
    return a + b;
}
void greet(int (*fPointer)(int, int))
{
    printf("Hello user, your sum is %d", fPointer(12, 5)); // this is how you can call one function into another
}
int main()
{
    int (*fPtr)(int, int); // giving the ability to store a function's address to fPtr. which will return integer in future and will take 2 integers as parameters
    fPtr = sum;            // giving address of 'sum' to ptr
    greet(fPtr);           // this is how passing a function into another as an argument
    return 0;
}

---------------------------------------------------
---------------------------------------------------

Alternative example of 'area of circle' by harry bhai;
addition and subtraction illustrating callback functions:

int sumSub(int a, int b)
{
    printf("Sum: %d, Subtraction: %d", a + b, a - b);
}
int middleMen(int a, int b, int (*sumSub)(int, int))
{
    return sumSub(a, b);
}
int main()
{
    int ae, bi, addSub;
    printf("Enter 1 number: ");
    scanf("%d", &ae);
    printf("Enter 2 number: ");
    scanf("%d", &bi);
    addSub = middleMen(ae, bi, sumSub);
    return 0;
}




















