/ *** DATATYPES IN C++ *** /
    string name = "harry";
    // int -> short (for short integers)
    int a = 2;
    int b = 3;
    short aVarWithShortMemoryAllocated;
    float aFloatWhichIsConstant = 45.32;
    // for declaring constant variables
    float const aFloatWhichIsConstant = 45.32;
    // float -> double (for long floats)
    double score2 = 45.322;

    // for longer integers
    long aVarWithLongMemoryAllocated;
    long long aVarWithVeryLongMemoryAllocated;
    long double score3 = 45.332;
    // << is known as 'insertion operator'
    cout << "Enter your name:" << endl;

    // Capturing input and storing into a variable
    // >> is called 'Extraction Operator'
    cin >> name;

    // Displaying a variable value; similarly for executing functions too instead of variables
    cout << "Hello " << name << " It's great to meet you!";

    // New line character in C++
    // endl or \n

    // Typecasting
    cout << "a / b is " << (float)a / b << endl;

/ *** Modules in C++ *** /
Like the modules in JS, we have modules in C++ which have the extension of .h and which can be included as other headers
i.e.
    #include "printTable.h"
    .
    .
    printTable(10);

(inside printTable.h)

#include <iostream>
using namespace std;

// 1 is the default value for num here
int printTable(int num=1)
{
    for (int i = 1; i < 11; i++)
    {
        cout << num << " X " << i << " = " << num * i << endl;
    }
}

/ *** GET THE GLOBAL VARIABLE *** /
int c = 1;
int main()
{
    int c = 2;
    cout << c;
    // This means print the global 'c' variable's value
    cout << ::c;
}

/ *** REFERENCE VARIABLES *** /
    int c = 2;
    // This means that b is referencing c's value
    int &b = c;
    cout << b << c; // 22
    // If you change the b, it'll also change c
    b = 3;
    cout << b << c; // 33

/ *** TYPECASTING *** /
    int a = 3;
    float b = 1.2001;
    cout << (float)a; // this is equivalent to float(a)
    cout << (int)b;

/ *** CONSTANTS *** /
    // You can write like both
    const int a = 3;
    int const a = 3;

/ *** MANIPULATORS *** /
1. endl - For moving the following code to a new line
2. setw(4) - This will align any character right which is going to be printed after this function, and will set its width to 4 characters(in this context). NOTE: You need to include <iomanip> library to use this func
i.e.
    int a = 12;
    cout << "a's value is " << setw(10) << a; // a's value is         12

/ *** POINTERS *** /
int a = 12;
    int *b = &a;
    // Pointer which points to the address of a pointer
    int **c = &b;
    cout << a << endl; // prints the actual value
    cout << b << endl; // prints the address of the actual value
    cout << c << endl; // prints the address of the pointer variable, which is storing the address of the actual value

/ *** Accessing array elements with just the first element's address *** /
    int a[] = {0, 1, 2};
    int *b = a;
    cout << b << endl;
    cout << ++b << endl;
    cout << ++b << endl;

/ *** Struct *** /
struct car
{
    int id;
    string modelName;
    string brand;
    float mileage;
    void introduce()
    {
        cout << "Hello, this is " << this->brand << " " << this->modelName << ", and I have a stunning mileage of " << this->mileage << " kmpl.";
    }
};

    struct car dreamCar1;
    dreamCar1.modelName = "Carens";
    dreamCar1.brand = "Kia";
    dreamCar1.mileage = 67.55;

    // Short hand to do just this
    dreamCar1 = {1, "Carens", "Kia", 67.55};


/ *** ALIAS IN struct *** /
typedef struct car
{
    int id;
    string modelName;
    string brand;
    float mileage;
    void introduce()
    {
        cout << "Hello, this is " << this->brand << " " << this->modelName << ", and I have a stunning mileage of " << this->mileage << " kmpl.";
    }
} automobile;

// Now, we can create structs like this:
    automobile dreamCar1;
// instead of writing the whole:
    struct car dreamCar1;

/ *** FUNCTIONS AND FUNCTION PROTOTYPES *** /

int sum(int a, int b);

// You can also just write like below, but only for prototype!
int sum(int, int);

int main() { cout << sum(1, 2); }

int sum(int a, int b) { return a + b; }


/ *** CALL BY REFERENCE *** /

void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Swapping variables with Call by reference using pointers
int main()
{
    int a = 6, b = 7;
    cout << a << b << endl;
    cout << a << b << endl;
    return 1;
}

// Swapping variables with reference variables
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

int main()
{
    int a = 6, b = 7;
    cout << a << b << endl;
    swap(a, b);
    cout << a << b << endl;
    return 1;
}

/ *** STATIC *** /

int pro()
{
    // This only stores the value once; next time, the value will stay incremented
    static int a = 0;
    return ++a;
}

int main()
{
    cout << pro(); // 1
    cout << pro(); // 2
    cout << pro(); // 3
    return 1;
}

/ *** RECURSION & FIBONACCI/FACTORIAL *** /

int fib(int num)
{
    if (num < 2)
        return num;
    return fib(num - 2) + fib(num - 1);
}

int factorial(int num)
{
    if (num == 1)
        return 1;
    return num = num * factorial(num - 1);
}

int main()
{
    cout << factorial(15);
    cout << fib(10);
    return 1;
}

/ ***FUNCTION OVERLOADING *** /
// The program first matches the parameter datatypes and their count, and then proceeds, the code will work totally fine even if there are more than one functions with the same name!

string add(string a, string b)
{
    return a + b;
}
int add(int a, int b, int c)
{
    return a + b + c;
}

int main()
{
    cout << add("Jeel ", "Patel") << endl;
    cout << add(1, 2, 3) << endl;
    return 1;
}

/ *** OBJECT ORIENTED PROGRAMMINGðŸ¤© *** /

class Car
{
private:
    // These can only be accessed by functions inside this scope
    int srNo, initialPrice;
    string ownerName;

public:
    // These can be accessed by outer functions
    string model, brand;
    void buyCar(string model, string brand)
    {
        this->model = model;
        this->brand = brand;
    }
    void setOwner(string name); // this is just declaration, we can define it later
    void info()
    {
        cout << "This is " << this->model << " from " << this->brand << ", and it is owned by " << this->ownerName << "." << endl;
    }
};

// This is how we can define an inner function of a class outside the class
:: is known as 'Scope Resolution Operator'
void Car ::setOwner(string name)
{
    this->ownerName = name;
}

main()
{
    // To count how many car objects are made with this class, you can use 'static' variables which are associated with the class and not the object, and it'll not be allocated for every object which is created and will be shared by all the created objects; i.e. static int count; // by default it starts with 0
    Car chevy;
    // This both below lines will not work as the variable 'ownerName' is not even read only, no one can either read or write it except its own parent class!
    chevy.ownerName = "Paresh";
    cout << chevy.ownerName;
    return 1;
}

/ *** OOPs - Classes and objects *** /

class --> extension of structures (in C)
structures had limitations
     - members are public
     - No methods
classes --> structures + more
classes --> can have methods and properties
classes --> can make few members as private & few as public
structures in C++ are typedefed

/ *** VERY MINI-PROJECT MULTIUTILITY using OOP *** /

/ *** STATIC FUNCTIONS *** /
Which basically accesses static variables, it cannot print variables except static variables

// This is how you can utilise it
*inside class*
static void getCount(){
    cout << count;
}
*inside main*
[ClassName]::getCount();


/ *** FRIEND FUNCTIONS *** /
They're nothing but the permission given by the main class to some function in order to execute some task outside the class to access the private variables and functions

SIMPLEST EXAMPLE OF FRIEND FUNCTIONS:
// This is known as Forward declaration; it is the assurity given by us to the compiler that even if there isn't a class Y, it will come up later in the code!
class Y;

class X
{
    int num = 7;
    // This is the permission statement, which basically means that if add() function is trying to access my private data, allow it to do that
    friend void add(X, Y);
    // If we want to friend a whole class, then just write the class name like below:
    class someClass;
};

class Y
{
    int num = 7;
    friend void add(X, Y);
};

void add(X one, Y two)
{
    cout << one.num + two.num;
}

int main()
{
    X a;
    Y b;
    add(a, b);
    return 1;
}

/ *** CONSTRUCTORS *** /
-> It can have default arguments like functions,
-> It can also work like function overloading, if there are more than one constructor in the class, the compiler will match its arguments and proceed accordingly

class Car
{
public:
    string name, brand;
    float mileage;
    // The constructor; which is invoked automatically whenever an object is created from this class
    // This forward declaration still needs to be here if you want to use the 2nd method to define constructor
    Car(string name, string brand, float mileage);
    void intro()
    {
        cout << "This is stunning " << this->brand << " " << this->name << " with a fantastic mileage of " << this->mileage << " kmpl." << endl;
    };
    // {
    //     this->name = name;
    //     this->brand = brand;
    //     this->mileage = mileage;
    // }
};

// Another way to define constructors; if you've any parameters in the constructor, then it is called parameterized constructor.
Car::Car(string name, string brand, float mileage)
{
    this->name = name;
    this->brand = brand;
    this->mileage = mileage;
}

int main()
{
    Car car1("Fantazma", "Lamborghini", 97.9);
    car1.intro();
    return 1;
}