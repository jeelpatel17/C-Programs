/ *** DATATYPES IN C++ *** /
    string name = "harry";
    // int -> short (for short integers)
    int a = 2;
    int b = 3;
    short aVarWithShortMemoryAllocated;
    float aFloatWhichIsConstant = 45.32;
    // for declaring constant variables
    float const aFloatWhichIsConstant = 45.32;
    // float -> double (for long floats)
    double score2 = 45.322;

    // for longer integers
    long aVarWithLongMemoryAllocated;
    long long aVarWithVeryLongMemoryAllocated;
    long double score3 = 45.332;
    // << is known as 'insertion operator'
    cout << "Enter your name:" << endl;

    // Capturing input and storing into a variable
    // >> is called 'Extraction Operator'
    cin >> name;

    // Displaying a variable value; similarly for executing functions too instead of variables
    cout << "Hello " << name << " It's great to meet you!";

    // New line character in C++
    // endl or \n

    // Typecasting
    cout << "a / b is " << (float)a / b << endl;

/ *** Modules in C++ *** /
Like the modules in JS, we have modules in C++ which have the extension of .h and which can be included as other headers
i.e.
    #include "printTable.h"
    .
    .
    printTable(10);

(inside printTable.h)

#include <iostream>
using namespace std;

// 1 is the default value for num here
int printTable(int num=1)
{
    for (int i = 1; i < 11; i++)
    {
        cout << num << " X " << i << " = " << num * i << endl;
    }
}

/ *** GET THE GLOBAL VARIABLE *** /
int c = 1;
int main()
{
    int c = 2;
    cout << c;
    // This means print the global 'c' variable's value
    cout << ::c;
}

/ *** REFERENCE VARIABLES *** /
    int c = 2;
    // This means that b is referencing c's value
    int &b = c;
    cout << b << c; // 22
    // If you change the b, it'll also change c
    b = 3;
    cout << b << c; // 33

/ *** TYPECASTING *** /
    int a = 3;
    float b = 1.2001;
    cout << (float)a; // this is equivalent to float(a)
    cout << (int)b;

/ *** CONSTANTS *** /
    // You can write like both
    const int a = 3;
    int const a = 3;

/ *** MANIPULATORS *** /
1. endl - For moving the following code to a new line
2. setw(4) - This will align any character right which is going to be printed after this function, and will set its width to 4 characters(in this context). NOTE: You need to include <iomanip> library to use this func
i.e.
    int a = 12;
    cout << "a's value is " << setw(10) << a; // a's value is         12

/ *** POINTERS *** /
int a = 12;
    int *b = &a;
    // Pointer which points to the address of a pointer
    int **c = &b;
    cout << a << endl; // prints the actual value
    cout << b << endl; // prints the address of the actual value
    cout << c << endl; // prints the address of the pointer variable, which is storing the address of the actual value

/ *** Accessing array elements with just the first element's address *** /
    int a[] = {0, 1, 2};
    int *b = a;
    cout << b << endl;
    cout << ++b << endl;
    cout << ++b << endl;

/ *** Constructors in C++, known as 'struct' *** /
struct car
{
    int id;
    string modelName;
    string brand;
    float mileage;
    void introduce()
    {
        cout << "Hello, this is " << this->brand << " " << this->modelName << ", and I have a stunning mileage of " << this->mileage << " kmpl.";
    }
};

    struct car dreamCar1;
    dreamCar1.modelName = "Carens";
    dreamCar1.brand = "Kia";
    dreamCar1.mileage = 67.55;

    // Short hand to do just this
    dreamCar1 = {1, "Carens", "Kia", 67.55};


/ *** ALIAS IN Constructors *** /
typedef struct car
{
    int id;
    string modelName;
    string brand;
    float mileage;
    void introduce()
    {
        cout << "Hello, this is " << this->brand << " " << this->modelName << ", and I have a stunning mileage of " << this->mileage << " kmpl.";
    }
} automobile;

// Now, we can create structs like this:
    automobile dreamCar1;
// instead of writing the whole:
    struct car dreamCar1;

/ *** FUNCTIONS AND FUNCTION PROTOTYPES *** /

int sum(int a, int b);

// You can also just write like below, but only for prototype!
int sum(int, int);

int main() { cout << sum(1, 2); }

int sum(int a, int b) { return a + b; }


/ *** CALL BY REFERENCE *** /

void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Swapping variables with Call by reference using pointers
int main()
{
    int a = 6, b = 7;
    cout << a << b << endl;
    cout << a << b << endl;
    return 1;
}

// Swapping variables with reference variables
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

int main()
{
    int a = 6, b = 7;
    cout << a << b << endl;
    swap(a, b);
    cout << a << b << endl;
    return 1;
}

/ *** STATIC *** /

int pro()
{
    // This only stores the value once; next time, the value will stay incremented
    static int a = 0;
    return ++a;
}

int main()
{
    cout << pro(); // 1
    cout << pro(); // 2
    cout << pro(); // 3
    return 1;
}

/ *** RECURSION & FIBONACCI/FACTORIAL *** /

int fib(int num)
{
    if (num < 2)
        return num;
    return fib(num - 2) + fib(num - 1);
}

int factorial(int num)
{
    if (num == 1)
        return 1;
    return num = num * factorial(num - 1);
}

int main()
{
    cout << factorial(15);
    cout << fib(10);
    return 1;
}

/ ***FUNCTION OVERLOADING *** /
// The program first matches the parameter datatypes and their count, and then proceeds, the code will work totally fine even if there are more than one functions with the same name!

string add(string a, string b)
{
    return a + b;
}
int add(int a, int b, int c)
{
    return a + b + c;
}

int main()
{
    cout << add("Jeel ", "Patel") << endl;
    cout << add(1, 2, 3) << endl;
    return 1;
}